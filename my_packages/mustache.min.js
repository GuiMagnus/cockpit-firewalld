/* @preserve: WARNING: This javascript file in the base1 package is deprecated */
console.warn("Deprecated: " + (new Error().fileName || "This javascript file").split("/").reverse()[0] + " in the Cockpit base1 package is deprecated");

// This file has been generated from mustache.mjs
(function(e, t) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = t() : typeof define === "function" && define.amd ? define(t) : (e = e || self, 
    e.Mustache = t());
})(this, function() {
    "use strict";
    /*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   */    var r = Object.prototype.toString;
    var E = Array.isArray || function e(t) {
        return r.call(t) === "[object Array]";
    };
    function c(e) {
        return typeof e === "function";
    }
    /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */    function a(e) {
        return E(e) ? "array" : typeof e;
    }
    function U(e) {
        return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */    function f(e, t) {
        return e != null && typeof e === "object" && t in e;
    }
    /**
   * Safe way of detecting whether or not the given thing is a primitive and
   * whether it has the given property
   */    function l(e, t) {
        return e != null && typeof e !== "object" && e.hasOwnProperty && e.hasOwnProperty(t);
    }
    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
    // See https://github.com/janl/mustache.js/issues/189
        var n = RegExp.prototype.test;
    function t(e, t) {
        return n.call(e, t);
    }
    var i = /\S/;
    function j(e) {
        return !t(i, e);
    }
    var s = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
    };
    function e(e) {
        return String(e).replace(/[&<>"'`=\/]/g, function e(t) {
            return s[t];
        });
    }
    var T = /\s*/;
    var P = /\s+/;
    var S = /\s*=/;
    var V = /\s*\}/;
    var O = /#|\^|\/|>|\{|&|=|!/;
    /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   *
   * Tokens for partials also contain two more elements: 1) a string value of
   * indendation prior to that tag and 2) the index of that tag on that line -
   * eg a value of 2 indicates the partial is the third tag on this line.
   */    function o(e, t) {
        if (!e) return [];
        var r = false;
        var n = [];
 // Stack to hold section tokens
                var i = [];
 // Buffer to hold the tokens
                var a = [];
 // Indices of whitespace tokens on the current line
                var s = false;
 // Is there a {{tag}} on the current line?
                var o = false;
 // Is there a non-space char on the current line?
                var u = "";
 // Tracks indentation for tags that use it
                var f = 0;
 // Stores a count of number of tags encountered on a line
        // Strips all whitespace tokens array for the current line
        // if there was a {{#tag}} on it and otherwise only space.
                function l() {
            if (s && !o) {
                while (a.length) delete i[a.pop()];
            } else {
                a = [];
            }
            s = false;
            o = false;
        }
        var c, p, h;
        function d(e) {
            if (typeof e === "string") e = e.split(P, 2);
            if (!E(e) || e.length !== 2) throw new Error("Invalid tags: " + e);
            c = new RegExp(U(e[0]) + "\\s*");
            p = new RegExp("\\s*" + U(e[1]));
            h = new RegExp("\\s*" + U("}" + e[1]));
        }
        d(t || _.tags);
        var v = new R(e);
        var g, w, y, m, k, b;
        while (!v.eos()) {
            g = v.pos;
            // Match any text between tags.
                        y = v.scanUntil(c);
            if (y) {
                for (var x = 0, C = y.length; x < C; ++x) {
                    m = y.charAt(x);
                    if (j(m)) {
                        a.push(i.length);
                        u += m;
                    } else {
                        o = true;
                        r = true;
                        u += " ";
                    }
                    i.push([ "text", m, g, g + 1 ]);
                    g += 1;
                    // Check for whitespace on the current line.
                                        if (m === "\n") {
                        l();
                        u = "";
                        f = 0;
                        r = false;
                    }
                }
            }
            // Match the opening tag.
                        if (!v.scan(c)) break;
            s = true;
            // Get the tag type.
                        w = v.scan(O) || "name";
            v.scan(T);
            // Get the tag value.
                        if (w === "=") {
                y = v.scanUntil(S);
                v.scan(S);
                v.scanUntil(p);
            } else if (w === "{") {
                y = v.scanUntil(h);
                v.scan(V);
                v.scanUntil(p);
                w = "&";
            } else {
                y = v.scanUntil(p);
            }
            // Match the closing tag.
                        if (!v.scan(p)) throw new Error("Unclosed tag at " + v.pos);
            if (w == ">") {
                k = [ w, y, g, v.pos, u, f, r ];
            } else {
                k = [ w, y, g, v.pos ];
            }
            f++;
            i.push(k);
            if (w === "#" || w === "^") {
                n.push(k);
            } else if (w === "/") {
                // Check section nesting.
                b = n.pop();
                if (!b) throw new Error('Unopened section "' + y + '" at ' + g);
                if (b[1] !== y) throw new Error('Unclosed section "' + b[1] + '" at ' + g);
            } else if (w === "name" || w === "{" || w === "&") {
                o = true;
            } else if (w === "=") {
                // Set the tags for the next time around.
                d(y);
            }
        }
        l();
        // Make sure there are no open sections when we're done.
                b = n.pop();
        if (b) throw new Error('Unclosed section "' + b[1] + '" at ' + v.pos);
        return I(A(i));
    }
    /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */    function A(e) {
        var t = [];
        var r, n;
        for (var i = 0, a = e.length; i < a; ++i) {
            r = e[i];
            if (r) {
                if (r[0] === "text" && n && n[0] === "text") {
                    n[1] += r[1];
                    n[3] = r[3];
                } else {
                    t.push(r);
                    n = r;
                }
            }
        }
        return t;
    }
    /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */    function I(e) {
        var t = [];
        var r = t;
        var n = [];
        var i, a;
        for (var s = 0, o = e.length; s < o; ++s) {
            i = e[s];
            switch (i[0]) {
              case "#":
              case "^":
                r.push(i);
                n.push(i);
                r = i[4] = [];
                break;

              case "/":
                a = n.pop();
                a[5] = i[2];
                r = n.length > 0 ? n[n.length - 1][4] : t;
                break;

              default:
                r.push(i);
            }
        }
        return t;
    }
    /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */    function R(e) {
        this.string = e;
        this.tail = e;
        this.pos = 0;
    }
    /**
   * Returns `true` if the tail is empty (end of string).
   */    R.prototype.eos = function e() {
        return this.tail === "";
    };
    /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */    R.prototype.scan = function e(t) {
        var r = this.tail.match(t);
        if (!r || r.index !== 0) return "";
        var n = r[0];
        this.tail = this.tail.substring(n.length);
        this.pos += n.length;
        return n;
    };
    /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */    R.prototype.scanUntil = function e(t) {
        var r = this.tail.search(t), n;
        switch (r) {
          case -1:
            n = this.tail;
            this.tail = "";
            break;

          case 0:
            n = "";
            break;

          default:
            n = this.tail.substring(0, r);
            this.tail = this.tail.substring(r);
        }
        this.pos += n.length;
        return n;
    };
    /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */    function u(e, t) {
        this.view = e;
        this.cache = {
            ".": this.view
        };
        this.parent = t;
    }
    /**
   * Creates a new context using the given view with this context
   * as the parent.
   */    u.prototype.push = function e(t) {
        return new u(t, this);
    };
    /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */    u.prototype.lookup = function e(t) {
        var r = this.cache;
        var n;
        if (r.hasOwnProperty(t)) {
            n = r[t];
        } else {
            var i = this, a, s, o, u = false;
            while (i) {
                if (t.indexOf(".") > 0) {
                    a = i.view;
                    s = t.split(".");
                    o = 0;
                    /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           *
           * In the case where dot notation is used, we consider the lookup
           * to be successful even if the last "object" in the path is
           * not actually an object but a primitive (e.g., a string, or an
           * integer), because it is sometimes useful to access a property
           * of an autoboxed primitive, such as the length of a string.
           **/                    while (a != null && o < s.length) {
                        if (o === s.length - 1) u = f(a, s[o]) || l(a, s[o]);
                        a = a[s[o++]];
                    }
                } else {
                    a = i.view[t];
                    /**
           * Only checking against `hasProperty`, which always returns `false` if
           * `context.view` is not an object. Deliberately omitting the check
           * against `primitiveHasOwnProperty` if dot notation is not used.
           *
           * Consider this example:
           * ```
           * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
           * ```
           *
           * If we were to check also against `primitiveHasOwnProperty`, as we do
           * in the dot notation case, then render call would return:
           *
           * "The length of a football field is 9."
           *
           * rather than the expected:
           *
           * "The length of a football field is 100 yards."
           **/                    u = f(i.view, t);
                }
                if (u) {
                    n = a;
                    break;
                }
                i = i.parent;
            }
            r[t] = n;
        }
        if (c(n)) n = n.call(this.view);
        return n;
    };
    /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */    function p() {
        this.templateCache = {
            _cache: {},
            set: function e(t, r) {
                this._cache[t] = r;
            },
            get: function e(t) {
                return this._cache[t];
            },
            clear: function e() {
                this._cache = {};
            }
        };
    }
    /**
   * Clears all cached templates in this writer.
   */    p.prototype.clearCache = function e() {
        if (typeof this.templateCache !== "undefined") {
            this.templateCache.clear();
        }
    };
    /**
   * Parses and caches the given `template` according to the given `tags` or
   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
   * that is generated from the parse.
   */    p.prototype.parse = function e(t, r) {
        var n = this.templateCache;
        var i = t + ":" + (r || _.tags).join(":");
        var a = typeof n !== "undefined";
        var s = a ? n.get(i) : undefined;
        if (s == undefined) {
            s = o(t, r);
            a && n.set(i, s);
        }
        return s;
    };
    /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   *
   * If the optional `tags` argument is given here it must be an array with two
   * string values: the opening and closing tags used in the template (e.g.
   * [ "<%", "%>" ]). The default is to mustache.tags.
   */    p.prototype.render = function e(t, r, n, i) {
        var a = this.parse(t, i);
        var s = r instanceof u ? r : new u(r, undefined);
        return this.renderTokens(a, s, n, t, i);
    };
    /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */    p.prototype.renderTokens = function e(t, r, n, i, a) {
        var s = "";
        var o, u, f;
        for (var l = 0, c = t.length; l < c; ++l) {
            f = undefined;
            o = t[l];
            u = o[0];
            if (u === "#") f = this.renderSection(o, r, n, i); else if (u === "^") f = this.renderInverted(o, r, n, i); else if (u === ">") f = this.renderPartial(o, r, n, a); else if (u === "&") f = this.unescapedValue(o, r); else if (u === "name") f = this.escapedValue(o, r); else if (u === "text") f = this.rawValue(o);
            if (f !== undefined) s += f;
        }
        return s;
    };
    p.prototype.renderSection = function e(t, r, n, i) {
        var a = this;
        var s = "";
        var o = r.lookup(t[1]);
        // This function is used to render an arbitrary template
        // in the current context by higher-order sections.
                function u(e) {
            return a.render(e, r, n);
        }
        if (!o) return;
        if (E(o)) {
            for (var f = 0, l = o.length; f < l; ++f) {
                s += this.renderTokens(t[4], r.push(o[f]), n, i);
            }
        } else if (typeof o === "object" || typeof o === "string" || typeof o === "number") {
            s += this.renderTokens(t[4], r.push(o), n, i);
        } else if (c(o)) {
            if (typeof i !== "string") throw new Error("Cannot use higher-order sections without the original template");
            // Extract the portion of the original template that the section contains.
                        o = o.call(r.view, i.slice(t[3], t[5]), u);
            if (o != null) s += o;
        } else {
            s += this.renderTokens(t[4], r, n, i);
        }
        return s;
    };
    p.prototype.renderInverted = function e(t, r, n, i) {
        var a = r.lookup(t[1]);
        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
                if (!a || E(a) && a.length === 0) return this.renderTokens(t[4], r, n, i);
    };
    p.prototype.indentPartial = function e(t, r, n) {
        var i = r.replace(/[^ \t]/g, "");
        var a = t.split("\n");
        for (var s = 0; s < a.length; s++) {
            if (a[s].length && (s > 0 || !n)) {
                a[s] = i + a[s];
            }
        }
        return a.join("\n");
    };
    p.prototype.renderPartial = function e(t, r, n, i) {
        if (!n) return;
        var a = c(n) ? n(t[1]) : n[t[1]];
        if (a != null) {
            var s = t[6];
            var o = t[5];
            var u = t[4];
            var f = a;
            if (o == 0 && u) {
                f = this.indentPartial(a, u, s);
            }
            return this.renderTokens(this.parse(f, i), r, n, f, i);
        }
    };
    p.prototype.unescapedValue = function e(t, r) {
        var n = r.lookup(t[1]);
        if (n != null) return n;
    };
    p.prototype.escapedValue = function e(t, r) {
        var n = r.lookup(t[1]);
        if (n != null) return _.escape(n);
    };
    p.prototype.rawValue = function e(t) {
        return t[1];
    };
    var _ = {
        name: "mustache.js",
        version: "4.0.1",
        tags: [ "{{", "}}" ],
        clearCache: undefined,
        escape: undefined,
        parse: undefined,
        render: undefined,
        Scanner: undefined,
        Context: undefined,
        Writer: undefined,
        /**
     * Allows a user to override the default caching strategy, by providing an
     * object with set, get and clear methods. This can also be used to disable
     * the cache by setting it to the literal `undefined`.
     */
        set templateCache(e) {
            h.templateCache = e;
        },
        /**
     * Gets the default or overridden caching object from the default writer.
     */
        get templateCache() {
            return h.templateCache;
        }
    };
    // All high-level mustache.* functions use this writer.
        var h = new p();
    /**
   * Clears all cached templates in the default writer.
   */    _.clearCache = function e() {
        return h.clearCache();
    };
    /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */    _.parse = function e(t, r) {
        return h.parse(t, r);
    };
    /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer. If the optional `tags` argument is given here it must be an
   * array with two string values: the opening and closing tags used in the
   * template (e.g. [ "<%", "%>" ]). The default is to mustache.tags.
   */    _.render = function e(t, r, n, i) {
        if (typeof t !== "string") {
            throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + a(t) + '" was given as the first ' + "argument for mustache#render(template, view, partials)");
        }
        return h.render(t, r, n, i);
    };
    // Export the escaping function so that the user may override it.
    // See https://github.com/janl/mustache.js/issues/244
        _.escape = e;
    // Export these mainly for testing, but also for advanced usage.
        _.Scanner = R;
    _.Context = u;
    _.Writer = p;
    return _;
});
//# sourceMappingURL=mustache.min.js.map